"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function toTxResult(transactionResponse, options) {
    return {
        hash: transactionResponse.hash,
        options,
        transactionResponse
    };
}
class GnosisSafeContractEthers {
    constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
            return this.contract.interface.encodeFunctionData(methodName, params);
        };
    }
    async getVersion() {
        return this.contract.VERSION();
    }
    getAddress() {
        return this.contract.address;
    }
    async getNonce() {
        return (await this.contract.nonce()).toNumber();
    }
    async getThreshold() {
        return (await this.contract.getThreshold()).toNumber();
    }
    async getOwners() {
        return this.contract.getOwners();
    }
    async isOwner(address) {
        return this.contract.isOwner(address);
    }
    async getTransactionHash(safeTransactionData) {
        return this.contract.getTransactionHash(safeTransactionData.to, safeTransactionData.value, safeTransactionData.data, safeTransactionData.operation, safeTransactionData.safeTxGas, safeTransactionData.baseGas, safeTransactionData.gasPrice, safeTransactionData.gasToken, safeTransactionData.refundReceiver, safeTransactionData.nonce);
    }
    async approvedHashes(ownerAddress, hash) {
        return this.contract.approvedHashes(ownerAddress, hash);
    }
    async approveHash(hash, options) {
        const txResponse = await this.contract.approveHash(hash, options);
        return toTxResult(txResponse, options);
    }
    async execTransaction(safeTransaction, options) {
        const txResponse = await this.contract.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), options);
        return toTxResult(txResponse, options);
    }
    async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toNumber();
    }
}
exports.default = GnosisSafeContractEthers;
//# sourceMappingURL=GnosisSafeContractEthers.js.map